import{_ as e,c as s,o as a,a as l}from"./app.790ffd25.js";const F=JSON.parse('{"title":"JavaScript","description":"","frontmatter":{},"headers":[{"level":2,"title":"var let const 区别","slug":"var-let-const-区别","link":"#var-let-const-区别","children":[]},{"level":2,"title":"Map Object 区别","slug":"map-object-区别","link":"#map-object-区别","children":[]},{"level":2,"title":"?.和??区别","slug":"和-区别","link":"#和-区别","children":[]},{"level":2,"title":"! 和 !! 区别","slug":"和-区别-1","link":"#和-区别-1","children":[]},{"level":2,"title":"|| 和 && 区别","slug":"和-区别-2","link":"#和-区别-2","children":[]},{"level":2,"title":"ES5 function 和 ES6 class","slug":"es5-function-和-es6-class","link":"#es5-function-和-es6-class","children":[]},{"level":2,"title":"== 和 === 比较流程","slug":"和-比较流程","link":"#和-比较流程","children":[]},{"level":2,"title":"基本数据类型","slug":"基本数据类型","link":"#基本数据类型","children":[]},{"level":2,"title":"引用数据类型","slug":"引用数据类型","link":"#引用数据类型","children":[]},{"level":2,"title":"this 指针及其使用场景","slug":"this-指针及其使用场景","link":"#this-指针及其使用场景","children":[]},{"level":2,"title":"call apply bind之间的区别","slug":"call-apply-bind之间的区别","link":"#call-apply-bind之间的区别","children":[]},{"level":2,"title":"原型与原型链","slug":"原型与原型链","link":"#原型与原型链","children":[]},{"level":2,"title":"箭头函数与普通函数的区别","slug":"箭头函数与普通函数的区别","link":"#箭头函数与普通函数的区别","children":[]},{"level":2,"title":"静态作用域","slug":"静态作用域","link":"#静态作用域","children":[]},{"level":2,"title":"执行上下文栈","slug":"执行上下文栈","link":"#执行上下文栈","children":[]},{"level":2,"title":"ES3规范执行上下文","slug":"es3规范执行上下文","link":"#es3规范执行上下文","children":[]},{"level":2,"title":"ES6规范执行上下文","slug":"es6规范执行上下文","link":"#es6规范执行上下文","children":[]},{"level":2,"title":"闭包","slug":"闭包","link":"#闭包","children":[]},{"level":2,"title":"Common JS与ES6 Modules规范的区别","slug":"common-js与es6-modules规范的区别","link":"#common-js与es6-modules规范的区别","children":[]},{"level":2,"title":"内存泄漏","slug":"内存泄漏","link":"#内存泄漏","children":[]},{"level":2,"title":"JS垃圾回收","slug":"js垃圾回收","link":"#js垃圾回收","children":[]},{"level":2,"title":"V8垃圾回收","slug":"v8垃圾回收","link":"#v8垃圾回收","children":[]},{"level":2,"title":"Promise","slug":"promise","link":"#promise","children":[]},{"level":2,"title":"Event loop","slug":"event-loop","link":"#event-loop","children":[]},{"level":2,"title":"Proxy与Reflect","slug":"proxy与reflect","link":"#proxy与reflect","children":[]},{"level":2,"title":"DOM事件和事件委托","slug":"dom事件和事件委托","link":"#dom事件和事件委托","children":[]},{"level":2,"title":"XHR和Fecth的区别","slug":"xhr和fecth的区别","link":"#xhr和fecth的区别","children":[]}],"relativePath":"guide/JS面试.md","lastUpdated":1673594167000}'),n={name:"guide/JS面试.md"},o=l(`<h1 id="javascript" tabindex="-1">JavaScript <a class="header-anchor" href="#javascript" aria-hidden="true">#</a></h1><h2 id="var-let-const-区别" tabindex="-1">var let const 区别 <a class="header-anchor" href="#var-let-const-区别" aria-hidden="true">#</a></h2><h4 id="var" tabindex="-1">var <a class="header-anchor" href="#var" aria-hidden="true">#</a></h4><ul><li>在<strong>ES5</strong>中，顶层对象的属性和全局变量是等价的，用<code>var</code>声明的变量既是全局变量，也是顶层变量</li><li>函数级作用域，在整个函数中都能起到作用，<code>var</code>为函数级作用域主要是因为以前内存小，如果每次声明块级作用域则会占用很大的内存，内存可能会爆掉</li><li>存在变量提升</li><li>可以重复声明同一变量（会覆盖）</li></ul><h4 id="let" tabindex="-1">let <a class="header-anchor" href="#let" aria-hidden="true">#</a></h4><ul><li>块级作用域，只在语句块中起到作用，比如<code>for</code>循环语句中</li><li>不存在变量提升</li><li>存在<code>TDZ</code>(暂时性死区)：只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。在<code>let</code>命令声明变量之前，都属于该变量的“死区”。总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</li><li>同一个作用域不可使用 <code>let</code> 重复声明同一个变量</li></ul><h4 id="const" tabindex="-1">const <a class="header-anchor" href="#const" aria-hidden="true">#</a></h4><ul><li>声明一个变量为只读的常量，但是只能保证基本数据类型的值不能改变，对与复合数据类型，则不能改变。<code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动</li><li>其他与<code>let</code>相似</li></ul><h2 id="map-object-区别" tabindex="-1">Map Object 区别 <a class="header-anchor" href="#map-object-区别" aria-hidden="true">#</a></h2><ul><li><code>Object</code>的键只能是<strong>字符串</strong>或者<strong>Symbol</strong>，<code>Map</code>的键值可以是<strong>任意值</strong></li><li>Map的键值对数量可以通过size属性获取，<code>Object</code>则需要通过<code>Object.keys(obj).length</code>类似的方式获取</li><li><code>Map </code>中的元素的顺序遵循插入的顺序，而 <code>Object </code>的则没有这一特性</li><li><code>Map</code>在存储大量元素、或者频繁的增加删除的时候性能表现更好</li></ul><h2 id="和-区别" tabindex="-1">?.和??区别 <a class="header-anchor" href="#和-区别" aria-hidden="true">#</a></h2><ul><li><code>?.</code>是可选链操作符，例如<code>let b = a?.name</code>，如果能访问到<code>name</code>，就会返回<code>name</code>的值；如果访问不到，则返回<code>undefined</code>而不会引起报错</li><li>形如<code>one ?? two</code>。使用<code>??</code>的时候只有<code>one</code>为<code>null</code>或<code>undefined</code>的时候才会返回<code>two</code>（空字符串不行），其他情况都会返回<code>one</code></li></ul><h2 id="和-区别-1" tabindex="-1">! 和 !! 区别 <a class="header-anchor" href="#和-区别-1" aria-hidden="true">#</a></h2><ul><li>使用<code>!</code>是取反操作，会变量转换成布尔类型，<code>null</code>、<code>undefined</code>和<code>&#39;&#39;</code>取反都为<code>true</code>，其余都为<code>false</code></li><li>使用<code>!!</code>是将表达式强制转化为布尔类型的运算，运算结果为<code>true</code>或<code>false</code>，表达式是什么值，结果就是对应的bool值</li></ul><h2 id="和-区别-2" tabindex="-1">|| 和 &amp;&amp; 区别 <a class="header-anchor" href="#和-区别-2" aria-hidden="true">#</a></h2><ul><li>使用<code>&amp;&amp;</code>的时候，只要有一个为假就为假。如果整体为<code>true</code>，则返回第二个的值；如果整体为<code>false</code>，就会返回第一个为假的值</li><li>使用<code>||</code>的时候，只要有一个为真就为真。如果第一个为真，则会返回第一个的值；其他情况都会则返回第二个的值</li></ul><h2 id="es5-function-和-es6-class" tabindex="-1">ES5 function 和 ES6 class <a class="header-anchor" href="#es5-function-和-es6-class" aria-hidden="true">#</a></h2><blockquote><p>在es5以前，主要通构造函数和原型链的方式定义一个类，本质上是一个function；而在es6中我们可以通过class关键字来定义一个类</p></blockquote><ul><li><code>class</code>必须<code>new</code>调用，不能直接执行；而<code>function</code>可以使用<code>new</code>也可以直接执行</li><li><code>class</code>不存在变量提升；而<code>function</code>存在变量提升</li><li>通过<code>new</code>一个<code>class</code>生成的实例，无法遍历到它原型链上的属性和方法</li><li><code>new.target</code>属性，通过这个属性，我们可以拿到<code>new</code>命令作用于的那个构造函数</li><li><code>class</code>有<code>static</code>静态方法，那么<code>static</code>方法需要使用这个类名去调用，而且<code>static</code>方法不会出现在实例上。如果<code>static</code>方法中包含<code>this</code>关键词，则这里的<code>this</code>指的是这个类而不是实例。<code>static</code>声明的属性和方法都会被子类所继承</li></ul><h2 id="和-比较流程" tabindex="-1">== 和 === 比较流程 <a class="header-anchor" href="#和-比较流程" aria-hidden="true">#</a></h2><p>首先说<code>==</code>：</p><ul><li>首先会判断两者类型是否相同。相同的话比大小，类型不相同的话，那么就会进行类型转换</li><li><code>undefined</code>和<code>null</code>互相比较返回<code>true</code>, 和自身比较也返回<code>true</code>, 其他情况返回<code>false</code></li><li><code>NaN</code>，<code>{}</code>，<code>[]</code>和任意值比较都是返回<code>false</code></li><li>如果一个值是布尔值，先把它转化成数字再进行比较，<code>true</code>转化成<code>1</code>，<code>false</code>转化成<code>0</code></li><li>如果是字符串和数字比较则会把字符串转化成对应的数字，如果是英文字母则会转化成<code>NaN</code></li><li>如果一个值是对象，另一个值是数字或字符串，将会先使用toString()和valueOf()将对象转换为原始值，然后再进行比较</li></ul><p>再说<code>===</code>：</p><ul><li>判断两者类型和值是否相同，类型不一致，直接返回<code>false</code>；否则继续比较两值的大小，如果是引用类型则指向的地址是否相等</li></ul><h2 id="基本数据类型" tabindex="-1">基本数据类型 <a class="header-anchor" href="#基本数据类型" aria-hidden="true">#</a></h2><blockquote><p>总结：四基两空，还有一个bigint</p></blockquote><ul><li>number</li><li>string</li><li>bool</li><li>symbol</li><li>null</li><li>undefined</li><li>bigint</li></ul><h2 id="引用数据类型" tabindex="-1">引用数据类型 <a class="header-anchor" href="#引用数据类型" aria-hidden="true">#</a></h2><ul><li>Object</li><li>Function</li><li>Date</li><li>Array</li><li>Map</li><li>Set</li><li>.....</li></ul><h2 id="this-指针及其使用场景" tabindex="-1">this 指针及其使用场景 <a class="header-anchor" href="#this-指针及其使用场景" aria-hidden="true">#</a></h2><blockquote><p><strong>原理：this 永远指向最后调用它的那个对象！</strong></p></blockquote><h4 id="场景一-全局环境下的this" tabindex="-1">场景一：全局环境下的this <a class="header-anchor" href="#场景一-全局环境下的this" aria-hidden="true">#</a></h4><ul><li>在非严格模式下，<code>this</code>指向的是<code>window</code>对象</li><li>在严格模式下，<code>this</code>值为<code>undefined</code></li></ul><h4 id="场景二-构造函数" tabindex="-1">场景二：构造函数 <a class="header-anchor" href="#场景二-构造函数" aria-hidden="true">#</a></h4><ul><li>当函数作为构造函数的时候，<code>this</code>指向的是<code>new</code>出来的新对象</li></ul><h4 id="场景三-函数作为对象的一个属性" tabindex="-1">场景三：函数作为对象的一个属性 <a class="header-anchor" href="#场景三-函数作为对象的一个属性" aria-hidden="true">#</a></h4><ul><li>函数作为对象的一个属性被调用的时候,<code>this</code>指向的是该对象</li></ul><h4 id="场景四" tabindex="-1">场景四 <a class="header-anchor" href="#场景四" aria-hidden="true">#</a></h4><ul><li>函数用<code>apply() call() bind()</code>调用时,<code>this</code>指向的是传入的对象</li></ul><h2 id="call-apply-bind之间的区别" tabindex="-1">call apply bind之间的区别 <a class="header-anchor" href="#call-apply-bind之间的区别" aria-hidden="true">#</a></h2><ul><li><p><code>call</code>与<code>apply</code>之间的区别只有一个，那就是<code>call</code>接收的是<strong>具体参数</strong>，<code>apply</code>接受的是<strong>包含参数的一个数组</strong>。参数确定或者顺序确定可以用<code>call</code>，其余最好用<code>apply</code></p></li><li><p><code>call/apply</code>改变了函数的<code>this</code>上下文后马上<strong>执行该函数</strong></p></li><li><p><code>bind</code>则是返回改变了<code>this</code>上下文后的函数的一份拷贝，<strong>不执行该函数</strong></p></li></ul><h2 id="原型与原型链" tabindex="-1">原型与原型链 <a class="header-anchor" href="#原型与原型链" aria-hidden="true">#</a></h2><ul><li><p>构造函数身上有一个<code>prototype</code>属性，指向构造函数的原型对象</p></li><li><p>通过构造函数new出来的实例对象会有一个<code>__proto__</code>属性，指向它的构造函数的原型对象的<code>prototype</code>,而这个<code>__proto__</code>属性是由浏览器提供的</p></li><li><p>原型链在执行查找时是一层一层向上的，原型链的终点是<code>null</code></p></li><li><p><code>Object </code>的原型对象也有<code>__proto__</code>属性指向<code>null</code></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44dde1c56e32490e92d7375e158096ba~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt=""></p></li></ul><h2 id="箭头函数与普通函数的区别" tabindex="-1">箭头函数与普通函数的区别 <a class="header-anchor" href="#箭头函数与普通函数的区别" aria-hidden="true">#</a></h2><ul><li><p>箭头函数没有<code>prototype</code>，因此它没有<code>this</code>属性</p></li><li><p>不能使用<code>new</code>关键词来实例化对象，会报错，因为箭头函数没有<code>constructor</code></p></li><li><p>当箭头函数外层有普通函数的时候，其<code>this</code>会指向定义时所在的第一个普通函数</p></li><li><p>当箭头函数外层没有普通函数的时候，在<strong>非严格模式</strong>和<strong>严格模式</strong>下<code>this</code>的值都是<code>window</code>，注意在对象中使用箭头函数的情况</p></li><li><p>箭头函数外层有普通函数时，<code>arguments</code>继承自<strong>外层普通函数</strong>的<code>arguments</code></p></li><li><p>箭头函数中的<code>this</code>指向的是定义时的<code>this</code>对象，而不是执行时的<code>this</code>对象</p></li></ul><h2 id="静态作用域" tabindex="-1">静态作用域 <a class="header-anchor" href="#静态作用域" aria-hidden="true">#</a></h2><ul><li>JavaScript采用的是静态作用域，也称是词法作用域</li><li>某个标识符属于哪个作用域或者作用域链关系，其实在书写时已经决定了</li></ul><h2 id="执行上下文栈" tabindex="-1">执行上下文栈 <a class="header-anchor" href="#执行上下文栈" aria-hidden="true">#</a></h2><ul><li>执行上下文栈初始化的时候，会最先压入一个<code>全局执行上下文</code>，并且只有当整个程序执行结束后，执行上下文栈才会被清空</li><li>每当执行一个函数的时候，就会创建一个<code>执行上下文</code>并且压入执行上下文栈中，当函数执行完毕的时候就会将它弹出</li></ul><h2 id="es3规范执行上下文" tabindex="-1">ES3规范执行上下文 <a class="header-anchor" href="#es3规范执行上下文" aria-hidden="true">#</a></h2><h4 id="类型" tabindex="-1">类型 <a class="header-anchor" href="#类型" aria-hidden="true">#</a></h4><ul><li>全局执行上下文</li><li>函数执行上下文</li><li>eval执行上下文</li></ul><h4 id="属性" tabindex="-1">属性 <a class="header-anchor" href="#属性" aria-hidden="true">#</a></h4><ul><li>变量对象(VO or AO)，注意只有<code>var</code>声明的变量才能存放到AO中</li><li>作用域链(Scope chain)</li><li>this</li></ul><h4 id="变量对象" tabindex="-1">变量对象 <a class="header-anchor" href="#变量对象" aria-hidden="true">#</a></h4><h5 id="函数的所有形参-如果是函数上下文" tabindex="-1">函数的所有形参 (如果是函数上下文) <a class="header-anchor" href="#函数的所有形参-如果是函数上下文" aria-hidden="true">#</a></h5><ul><li>由名称和对应值组成的一个变量对象的属性被创建</li><li>没有实参，属性值设为 undefined</li></ul><h5 id="函数声明" tabindex="-1">函数声明 <a class="header-anchor" href="#函数声明" aria-hidden="true">#</a></h5><ul><li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li><li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li></ul><h5 id="变量声明" tabindex="-1">变量声明 <a class="header-anchor" href="#变量声明" aria-hidden="true">#</a></h5><ul><li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li><li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li></ul><h4 id="作用域链" tabindex="-1">作用域链 <a class="header-anchor" href="#作用域链" aria-hidden="true">#</a></h4><h5 id="含义" tabindex="-1">含义 <a class="header-anchor" href="#含义" aria-hidden="true">#</a></h5><p>查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p><h5 id="原因" tabindex="-1">原因 <a class="header-anchor" href="#原因" aria-hidden="true">#</a></h5><p>这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！</p><h4 id="this规范深入" tabindex="-1">this规范深入 <a class="header-anchor" href="#this规范深入" aria-hidden="true">#</a></h4><blockquote><p><strong>1.Let <em>ref</em> be the result of evaluating MemberExpression.</strong></p><p><strong>6.If Type(<em>ref</em>) is Reference, then</strong></p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">  a</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">If </span><span style="color:#82AAFF;">IsPropertyReference</span><span style="color:#A6ACCD;">(ref) is </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> then</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">      i</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">Let thisValue be </span><span style="color:#82AAFF;">GetBase</span><span style="color:#A6ACCD;">(ref)</span><span style="color:#89DDFF;">.</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  b</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">Else</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> the base </span><span style="color:#89DDFF;">of</span><span style="color:#A6ACCD;"> ref is an Environment Record</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">      i</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">Let thisValue be the result </span><span style="color:#89DDFF;">of</span><span style="color:#A6ACCD;"> calling the ImplicitThisValue concrete method </span><span style="color:#89DDFF;">of</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">GetBase</span><span style="color:#A6ACCD;">(ref)</span><span style="color:#89DDFF;">.</span></span>
<span class="line"></span></code></pre></div><p><strong>7.Else, Type(<em>ref</em>) is not Reference.</strong></p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">  a</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;"> Let thisValue be undefined</span><span style="color:#89DDFF;">.</span></span>
<span class="line"></span></code></pre></div></blockquote><p><strong>MemberExpression</strong>简单理解可以为()左边的部分</p><h2 id="es6规范执行上下文" tabindex="-1">ES6规范执行上下文 <a class="header-anchor" href="#es6规范执行上下文" aria-hidden="true">#</a></h2><h4 id="类型-1" tabindex="-1">类型 <a class="header-anchor" href="#类型-1" aria-hidden="true">#</a></h4><ul><li>全局执行上下文</li><li>函数执行上下文</li><li>eval执行上下文</li></ul><h4 id="两个环境" tabindex="-1">两个环境 <a class="header-anchor" href="#两个环境" aria-hidden="true">#</a></h4><ul><li>词法环境<code>LexicalEnvironment</code></li><li>变量环境<code>VariableEnvironment</code></li></ul><h4 id="词法环境lexicalenvironment" tabindex="-1">词法环境LexicalEnvironment <a class="header-anchor" href="#词法环境lexicalenvironment" aria-hidden="true">#</a></h4><p>词法环境是<code>ECMA</code>中的一个规范，简单来说，词法环境就是建立了标识符----&gt;变量引用地址的映射表，<code>LexicalEnvironment</code>只存储函数声明和<code>let/const</code>声明的变量</p><h5 id="词法环境lexicalenvironment的类型" tabindex="-1">词法环境LexicalEnvironment的类型 <a class="header-anchor" href="#词法环境lexicalenvironment的类型" aria-hidden="true">#</a></h5><ul><li>全局环境(<code>GlobalEnvironment</code>)：在<code>JS</code>运行开始的时候，浏览器就会创建全局执行上下文的时候就会有这个全局环境</li><li>函数环境(<code>FunctionEnvironment</code>)：每一次调用函数时都会产生函数环境，在<code>ER</code>中也会记录该函数的<code>length</code>和<code>arguments</code>属性，而且函数环境的<code>outer</code>引用会指向调用起该函数的父环境</li><li>模块环境(<code>ModuleEnvironment</code>)：模块环境中可以读取到例如<code>module</code>、<code>export</code>变量。模块环境的<code>outer</code>引用指向全局环境</li></ul><h5 id="词法环境lexicalenvironment两个部分的构成" tabindex="-1">词法环境LexicalEnvironment两个部分的构成 <a class="header-anchor" href="#词法环境lexicalenvironment两个部分的构成" aria-hidden="true">#</a></h5><ul><li>环境记录<code>EnvironmentRecord</code>：存放变量和函数声明的地方，其中<code>this</code>也在这里</li><li>外层引用<code>outer</code>：提供了访问父级词法环境的引用，可能为<code>null</code></li></ul><h5 id="环境记录environmentrecord" tabindex="-1">环境记录EnvironmentRecord <a class="header-anchor" href="#环境记录environmentrecord" aria-hidden="true">#</a></h5><h6 id="两种类型" tabindex="-1">两种类型 <a class="header-anchor" href="#两种类型" aria-hidden="true">#</a></h6><ul><li>declarative EnvironmentRecord（一般来说都是declarative）</li><li>object EnvironmentRecord（一般来说由with语句触发，特殊地，全局ER类型为declarative和object混合，但是视作为object）</li></ul><h5 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-hidden="true">#</a></h5><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">词法环境 = EnvironmentRecord + outer</span></span>
<span class="line"><span style="color:#A6ACCD;">词法环境分类 = 全局 or 函数 or 模块</span></span>
<span class="line"><span style="color:#A6ACCD;">EnvironmentRecord分类 = declarative or object</span></span>
<span class="line"><span style="color:#A6ACCD;">GlobalEnvironmentRecord = declarative + object</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h4 id="变量环境variableenvironment" tabindex="-1">变量环境VariableEnvironment <a class="header-anchor" href="#变量环境variableenvironment" aria-hidden="true">#</a></h4><p>在<code>ES6</code>中提倡使用<code>let/const</code>去声明变量，但是为了兼顾<code>ES3</code>中的<code>var</code>的写法以及让他们做一个区分，于是使用变量环境去存储使用<code>var</code>声明的变量。变量环境大体上是和词法环境差不多的。只不过用<code>var</code>声明的变量一开始的值为<code>undefined</code>，并且存在变量提升</p><h2 id="闭包" tabindex="-1">闭包 <a class="header-anchor" href="#闭包" aria-hidden="true">#</a></h2><h4 id="闭包的定义" tabindex="-1">闭包的定义 <a class="header-anchor" href="#闭包的定义" aria-hidden="true">#</a></h4><blockquote><p>闭包是指有权访问另一个函数作用域中的自由变量的函数</p></blockquote><h4 id="闭包变量存储的位置" tabindex="-1">闭包变量存储的位置 <a class="header-anchor" href="#闭包变量存储的位置" aria-hidden="true">#</a></h4><blockquote><p>闭包中的变量存储的位置是堆内存</p></blockquote><h4 id="闭包作用" tabindex="-1">闭包作用 <a class="header-anchor" href="#闭包作用" aria-hidden="true">#</a></h4><ul><li>保护私有变量</li><li>防止全局变量污染严重</li><li>实现单例模式</li><li>自执行函数</li><li>节流防抖</li><li>回调函数</li><li>柯里化</li></ul><h4 id="闭包与内存泄漏" tabindex="-1">闭包与内存泄漏 <a class="header-anchor" href="#闭包与内存泄漏" aria-hidden="true">#</a></h4><p>内部函数引用了外部函数的局部变量，然后通过<code>return</code>将内部函数暴露在了全局作用域并用一个引用去接收，这样的形式，外部函数的执行上下文被摧毁了但是它的局部变量仍然没有被摧毁，这个时候其实也就会造成了内存泄漏。但其实闭包不一定会造成内存泄漏，只是我们在一些情况下很可能造成循环引用的情况，比如<code>DOM</code>引用，这样的不正当使用就会造成内存泄漏，这里可以用<code>null</code>解决</p><h4 id="检查内存泄漏" tabindex="-1">检查内存泄漏 <a class="header-anchor" href="#检查内存泄漏" aria-hidden="true">#</a></h4><blockquote><p>performance 面板 和 memory 面板可以找到泄露的现象和位置</p></blockquote><h2 id="common-js与es6-modules规范的区别" tabindex="-1">Common JS与ES6 Modules规范的区别 <a class="header-anchor" href="#common-js与es6-modules规范的区别" aria-hidden="true">#</a></h2><ul><li>CommonJS模块是运行时加载，因为像<code>require</code>这一些函数需要在执行阶段的时候才会被实例化；ES6 Modules是编译时输出接口，因为<code>import</code>和<code>export</code>这些关键词在编译阶段就做了模块解析</li><li>CommonJS运行在服务端，同步加载；ES6 Modules运行在浏览器，异步加载</li><li>CommonJS输出是值的拷贝；ES6 Modules输出的是值的引用，被输出模块的内部的改变会影响引用的改变</li><li>CommonJs导入的模块路径可以是一个表达式，因为它使用的是<code>require()</code>方法；而ES6 Modules只能是字符串</li><li>CommonJS <code>this</code>指向当前模块，ES6 Modules <code>this</code>指向<code>undefined</code></li><li>且ES6 Modules中没有这些顶层变量：<code>arguments</code>、<code>require</code>、<code>module</code>、<code>exports</code>、<code>__filename</code>、<code>__dirname</code></li></ul><h2 id="内存泄漏" tabindex="-1">内存泄漏 <a class="header-anchor" href="#内存泄漏" aria-hidden="true">#</a></h2><ul><li>意外的全局变量：由于使用了未声明的变量，而意外创建了一个全局变量而无法被回收</li><li>被遗忘的计时器</li><li>脱离DOM的引用： 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收</li><li>闭包：不合理的使用会导致某些变量一直留在内存中</li></ul><h2 id="js垃圾回收" tabindex="-1">JS垃圾回收 <a class="header-anchor" href="#js垃圾回收" aria-hidden="true">#</a></h2><blockquote><p>垃圾回收就是需要定期找出不再用到的变量，然后释放它所占用的内存</p></blockquote><h4 id="标记清理-常用" tabindex="-1">标记清理（常用） <a class="header-anchor" href="#标记清理-常用" aria-hidden="true">#</a></h4><blockquote><p>这个过程分为两个，一个是标记，另一个是清理</p></blockquote><h5 id="过程" tabindex="-1">过程 <a class="header-anchor" href="#过程" aria-hidden="true">#</a></h5><ul><li><p>首先说标记，标记的方式有很多种，比如当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”的两个变量列表，具体怎么实现不重要，重要的是这个策略。</p></li><li><p>然后说清理，垃圾收集器在运行的时候会给内存中所有的变量都加上一个标记，假设内存里的对象都是垃圾，全部标记为0；然后垃圾收集器会遍历各个根对象，把不是垃圾的节点更改为1；然后清除标记为0的垃圾，释放所占用的内存</p></li></ul><h5 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-hidden="true">#</a></h5><p>实现简单，就是打上标记这个动作，用或不用只有两种状态，这样的话就可以用一位二进制就能实现</p><h5 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-hidden="true">#</a></h5><p>标记清除算法有一个很大的缺点，就是在清除之后，剩余对象的位置是不变的，也就会导致空闲内存空间是不连续的。而关于这个问题，使用<strong>标记整理算法</strong>就可以有效解决，这个算法其实就是把所有活着的对象向一端移动，最后释放掉边界的内存</p><h4 id="引用计数-不常用" tabindex="-1">引用计数（不常用） <a class="header-anchor" href="#引用计数-不常用" aria-hidden="true">#</a></h4><blockquote><p>这个其实是最先的一种垃圾回收算法，其思路就是对每个值都记录它被引用的次数</p></blockquote><h5 id="过程-1" tabindex="-1">过程 <a class="header-anchor" href="#过程-1" aria-hidden="true">#</a></h5><ul><li>当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1</li><li>如果同一个值又被赋给另一个变量，那么引用数加 1</li><li>当这个变量的值被其他值给覆盖了，那么这个值的引用次数就减1</li><li>当这个值的引用次数变为0的时候，就说明这个值就没法被访问了，因此可以进行回收</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#A6ACCD;">() 	</span><span style="color:#676E95;font-style:italic;">// 此对象的引用计数为 1（a引用）</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> a 		</span><span style="color:#676E95;font-style:italic;">// 此对象的引用计数是 2（a引用,b引用）</span></span>
<span class="line"><span style="color:#A6ACCD;">a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null</span><span style="color:#A6ACCD;">  		</span><span style="color:#676E95;font-style:italic;">// 此对象的引用计数为 1（b引用）</span></span>
<span class="line"><span style="color:#A6ACCD;">b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null</span><span style="color:#A6ACCD;"> 	 	</span><span style="color:#676E95;font-style:italic;">// 此对象的引用计数为 0（无引用）</span></span>
<span class="line"><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;">			</span><span style="color:#676E95;font-style:italic;">// GC 回收此对象</span></span>
<span class="line"></span></code></pre></div><h5 id="缺点-1" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-1" aria-hidden="true">#</a></h5><p>首先是计数器会占很大的位置，然后是无法解决循环引用的问题</p><h2 id="v8垃圾回收" tabindex="-1">V8垃圾回收 <a class="header-anchor" href="#v8垃圾回收" aria-hidden="true">#</a></h2><blockquote><p>V8垃圾回收算法也是基于<strong>标记清理算法</strong>的，不过做了一些优化</p></blockquote><h4 id="分代收集" tabindex="-1">分代收集 <a class="header-anchor" href="#分代收集" aria-hidden="true">#</a></h4><blockquote><p>在V8中会将堆分成两个区域</p></blockquote><ul><li><strong>新生代</strong>：存放的是生存时间短的对象，通常大小只支持<strong>1~8M</strong>的容量，副垃圾回收器负责新生代区</li><li><strong>老生代</strong>：存放的是生存时间久的对象，支持的容量大很多，主垃圾回收器负责老生代区</li></ul><h4 id="新生代回收" tabindex="-1">新生代回收 <a class="header-anchor" href="#新生代回收" aria-hidden="true">#</a></h4><blockquote><p>新生代中用 <strong>Scavenge</strong> 算法来处理，也就是把新生代空间对半划分为两个区域，<strong>一半是对象区域</strong>，<strong>一半是空闲区域</strong>，一般来说，新加入的对象都会存放到对象区域</p></blockquote><p><img src="http://songnian.gitee.io/imgs/imgs/V8%E6%96%B0%E7%94%9F%E4%BB%A3Scavenge.png" alt=""></p><h5 id="回收过程" tabindex="-1">回收过程 <a class="header-anchor" href="#回收过程" aria-hidden="true">#</a></h5><ul><li>为 <strong>对象区域</strong> 中的垃圾做 <strong>标记</strong></li><li>标记完成之后，就进入 <strong>垃圾清理阶段</strong>，<strong>副垃圾回收器</strong> 会把这些 <strong>存活</strong> 的对象 <strong>复制</strong> 到 <strong>空闲区域</strong> 中</li><li>由于上一步的操作，使得不会有 <strong>内存碎片</strong> 产生，也没必要进行 <strong>内存整理</strong></li><li>完成复制后，<strong>对象区域</strong> 与 <strong>空闲区域</strong> 进行角色 <strong>翻转</strong>，即原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域</li></ul><h4 id="老生代回收" tabindex="-1">老生代回收 <a class="header-anchor" href="#老生代回收" aria-hidden="true">#</a></h4><p>老生代回收算法就是用了标记整理法结合，这个算法的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存</p><h4 id="全停顿" tabindex="-1">全停顿 <a class="header-anchor" href="#全停顿" aria-hidden="true">#</a></h4><p>全停顿实际上就是主线程一旦执行垃圾回收程序，其他正在执行的js脚本都会被暂停下来，直到垃圾回收程序执行结束，这样的话垃圾回收就会占用了很多时间</p><h4 id="增量标记" tabindex="-1">增量标记 <a class="header-anchor" href="#增量标记" aria-hidden="true">#</a></h4><p>增量标记算法的出现就是为了解决全停顿耗时过多的问题，<strong>增量标记算法</strong>，把一个完整的垃圾回收任务 <strong>拆分为很多小任务</strong>，这些小任务执行时间比较短，可以 <strong>穿插</strong> 在其他的 <strong>JavaScript</strong> 任务中间执行</p><h2 id="promise" tabindex="-1">Promise <a class="header-anchor" href="#promise" aria-hidden="true">#</a></h2><blockquote><p>Promise是异步编程的一种解决方案，可以解决回调地狱的问题，它有三个状态，分别是pending、fulfilled、rejected，一旦状态改变就不会再变，任何时候都会得到这个结果</p></blockquote><h4 id="流程图" tabindex="-1">流程图 <a class="header-anchor" href="#流程图" aria-hidden="true">#</a></h4><p><img src="http://songnian.gitee.io/imgs/imgs/Promise.png" alt=""></p><h4 id="常见方法" tabindex="-1">常见方法 <a class="header-anchor" href="#常见方法" aria-hidden="true">#</a></h4><ul><li><strong>resolve</strong>：将pending状态变为fulfilled状态，返回一个fulfilled状态的promise对象</li><li><strong>reject</strong>：将pending状态变为rejected状态，返回一个rejected状态的promise对象</li><li><strong>all</strong>：接收一个promise数组，如果里面的promise的状态全为fulfilled，则返回Promise的resolve的回调的value的数组，如果当中有一个的状态为rejected，则立即返回promise，且状态更改为rejected</li><li><strong>any</strong>：接收一个promise数组，如果里面的promise的状态全为rejected，则返回Promise的rejected的回调的err的数组，如果当中有一个的状态为fulfilled，则立即返回promise，且状态更改为fulfilled</li><li><strong>race</strong>：当传入的所有的promise其中有任何一个状态变成fulfilled或者rejected，则执行相应的回调</li></ul><h4 id="一些特性" tabindex="-1">一些特性 <a class="header-anchor" href="#一些特性" aria-hidden="true">#</a></h4><h5 id="值穿透" tabindex="-1">值穿透 <a class="header-anchor" href="#值穿透" aria-hidden="true">#</a></h5><blockquote><p>值穿透指的是，链式调用的参数不是函数时，会发生值穿透，就传入的非函数值忽略，传入的是之前的函数参数</p></blockquote><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 正常</span></span>
<span class="line"><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">2</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">3</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(console</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">log)</span></span>
<span class="line"><span style="color:#89DDFF;">	</span><span style="color:#676E95;font-style:italic;">//输出 3</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 值穿透</span></span>
<span class="line"><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">))</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(console</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">log)</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 输出 1</span></span>
<span class="line"></span></code></pre></div><h2 id="event-loop" tabindex="-1">Event loop <a class="header-anchor" href="#event-loop" aria-hidden="true">#</a></h2><h4 id="为什么js是单线程" tabindex="-1">为什么js是单线程？ <a class="header-anchor" href="#为什么js是单线程" aria-hidden="true">#</a></h4><p>javascript作为浏览器的脚本语言，主要的用途就是跟用户交互和操作DOM。假如不是单线程的话，当一个线程给某个DOM添加内容，而另外一个线程在删除这个DOM，那么情况就变得很复杂了，因此javascript应当就是个单线程</p><h4 id="同步与异步" tabindex="-1">同步与异步 <a class="header-anchor" href="#同步与异步" aria-hidden="true">#</a></h4><p>javascript实现了处理同步任务和异步任务，当遇到同步任务的时候就会交给主线程直接解决，当遇到异步任务的时候，就会把这些任务暂时放在任务队列里面，而异步任务又分为宏任务和微任务，分别会有对应的两个任务队列。总的来说，执行的时候，执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。优先级来说同步优先于异步，微任务优先于宏任务。</p><h4 id="宏任务和微任务" tabindex="-1">宏任务和微任务 <a class="header-anchor" href="#宏任务和微任务" aria-hidden="true">#</a></h4><ul><li>宏任务(macro)：script(整体代码)、setTimout、setInterval、I/O、交互事件、UI渲染</li><li>微任务(micro)：promise.then、nextTick、await后面的语句（需要等到await有处理结果后，后面的语句才能加入任务队列）</li></ul><h2 id="proxy与reflect" tabindex="-1">Proxy与Reflect <a class="header-anchor" href="#proxy与reflect" aria-hidden="true">#</a></h2><h4 id="proxy" tabindex="-1">Proxy <a class="header-anchor" href="#proxy" aria-hidden="true">#</a></h4><p><code>Proxy</code>代理就是通过<code>Proxy</code>拦截对一个对象的基本操作，对于一些复合的操作，<code>Proxy </code>是拦截不到的，因为它不是深度监测，比如<code>p.a.b</code>触发的是<code>key</code>为<code>a</code>的<code>get</code>函数</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> data </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">jack</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> p </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Proxy</span><span style="color:#A6ACCD;">(data</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">	</span><span style="color:#676E95;font-style:italic;">//拦截属性取值操作</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#F07178;">get</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">target</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">key</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">receiver</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">		</span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#F07178;">		</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">receiver === p ? </span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">receiver</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">p</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// false</span></span>
<span class="line"><span style="color:#F07178;">		</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">receiver === obj ? </span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">receiver</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"><span style="color:#F07178;">		</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">this === obj ? </span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// false</span></span>
<span class="line"><span style="color:#F07178;">		</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">target</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">key</span><span style="color:#F07178;">]</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#89DDFF;">	</span><span style="color:#676E95;font-style:italic;">//拦截属性设置操作</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#F07178;">set</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">target</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">key</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">value</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">		</span><span style="color:#676E95;font-style:italic;">//...</span></span>
<span class="line"><span style="color:#F07178;">		</span><span style="color:#A6ACCD;">target</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">key</span><span style="color:#F07178;">] </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">		</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">target</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">key</span><span style="color:#F07178;">]</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{};</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 设置obj继承与parent的代理对象p</span></span>
<span class="line"><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setPrototypeOf</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> p)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// jack</span></span>
<span class="line"></span></code></pre></div><p>其中<code>get</code>陷阱中的<code>receiver </code>存在的意义就是为了正确的在陷阱中传递上下文，请注意这里的<code>this</code>指向的是<code>handler</code>对象</p><h4 id="reflect" tabindex="-1">Reflect <a class="header-anchor" href="#reflect" aria-hidden="true">#</a></h4><p><code>Reflect</code>是一个全局内置的对象，它提供拦截<code>JavaScript</code>操作的方法。但是，<code>Reflect</code>本身不是个函数对象，因此其不是一个构造函数，不能使用new进行调用。<code>Reflect</code>的所有属性和方法都是静态的</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">Reflect</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#A6ACCD;">(target</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> key</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">receiver)</span><span style="color:#676E95;font-style:italic;">//在一个对象上读取值</span></span>
<span class="line"><span style="color:#A6ACCD;">Reflect</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">set</span><span style="color:#A6ACCD;">(target</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> key</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">value)</span><span style="color:#676E95;font-style:italic;">//在一个对象上设置属性</span></span>
<span class="line"></span></code></pre></div><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> p </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Proxy</span><span style="color:#A6ACCD;">(data</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">get</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">target</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">property</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">receiver</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// obj继承data，想要返回obj自身的属性值就执行下面这句</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Reflect</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">property</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">receiver</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//  等价于 return target[property].call(receiver);</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 想返回data中的属性值就执行下面这句</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// return Reflect.get(target, property);</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 等价于return target[property];</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h4><p>在<code>Vue3</code>中使用<code>Proxy</code>来实现响应式数据，具体就是通过<code>Proxy</code>拦截和修改对象的基本操作。在代理过程中，会出现<code>get</code>中的<code>this</code>指向问题，这个时候就需要使用<code>Reflect</code>的方法第三个参数<code>receiver</code>来解决，相当于用<code>call</code>改变了<code>this</code>指向。</p><h2 id="dom事件和事件委托" tabindex="-1">DOM事件和事件委托 <a class="header-anchor" href="#dom事件和事件委托" aria-hidden="true">#</a></h2><h4 id="dom事件" tabindex="-1">DOM事件 <a class="header-anchor" href="#dom事件" aria-hidden="true">#</a></h4><ul><li>事件捕捉：从外向内找到监听函数的过程</li><li>事件冒泡：从内向外的过程，默认情况下事件执行也在这个阶段</li><li>e.target： 用户操作的元素</li><li>e.currentTarget：程序员监听的元素</li><li>e.stopPropagation()：取消冒泡</li></ul><h4 id="事件委托" tabindex="-1">事件委托 <a class="header-anchor" href="#事件委托" aria-hidden="true">#</a></h4><blockquote><p>就是当事件触发时，把要做的事委托给父元素来处理</p></blockquote><p><strong>优点</strong>：节约内存，减少监听，能为之后新增的DOM元素依然添加事件</p><h2 id="xhr和fecth的区别" tabindex="-1">XHR和Fecth的区别 <a class="header-anchor" href="#xhr和fecth的区别" aria-hidden="true">#</a></h2><ul><li><code>XHR</code>可以监控进度和中断请求，而<code>Fetch</code>请求不可以</li><li><code>Fetch</code>只对网络错误或者跨域报错，对于<code>http</code>状态码错误不报错</li><li><code>Fetch</code>不支持超时控制，不支持<code>abort</code></li><li>默认情况下<code>Fetch</code>不发送<code>cookie</code>，除非手动配置<code>credentials </code>属性</li><li><code>Fetch</code>的语法更简洁，更语义化，并且基于<code>Promise</code></li></ul>`,171),c=[o];function t(r,p,i,d,h,y){return a(),s("div",null,c)}const u=e(n,[["render",t]]);export{F as __pageData,u as default};
