import{_ as s,c as e,o,a}from"./app.ed024433.js";const h=JSON.parse('{"title":"Vue源码","description":"","frontmatter":{},"headers":[{"level":2,"title":"变化侦测","slug":"变化侦测","link":"#变化侦测","children":[]},{"level":2,"title":"虚拟DOM","slug":"虚拟dom","link":"#虚拟dom","children":[]}],"relativePath":"guide/Vue源码.md","lastUpdated":1673594167000}'),n={name:"guide/Vue源码.md"},l=a(`<h1 id="vue源码" tabindex="-1">Vue源码 <a class="header-anchor" href="#vue源码" aria-hidden="true">#</a></h1><h2 id="变化侦测" tabindex="-1">变化侦测 <a class="header-anchor" href="#变化侦测" aria-hidden="true">#</a></h2><h4 id="object的变化侦测" tabindex="-1">Object的变化侦测 <a class="header-anchor" href="#object的变化侦测" aria-hidden="true">#</a></h4><blockquote><p>Object.defineProperty() 来观测对象数据的读和写</p></blockquote><h5 id="observer类" tabindex="-1">Observer类 <a class="header-anchor" href="#observer类" aria-hidden="true">#</a></h5><ul><li>调用<code>defineReactive</code>递归将一个对象所有属性都转化成可观测的对象</li><li>在其构造函数中给<code>value</code>新增一个<code>__ob__</code>属性，指向该<code>value</code>的<code>Observer</code>实例，可以避免重复操作</li><li>只有<code>object</code>类型的数据才会调用<code>walk</code>将每一个属性转换成<code>getter/setter</code>的形式来侦测变化</li></ul><h5 id="dep类" tabindex="-1">Dep类 <a class="header-anchor" href="#dep类" aria-hidden="true">#</a></h5><blockquote><p>谁用到了数据，谁就是依赖(watcher)，Dep来就是管理这些依赖的管理工具。并且在get中收集依赖，在set中通知依赖更新</p></blockquote><ul><li>在构造函数中创建了<code>subs</code>数组，用来存放依赖</li><li>定义了几个实例方法用来对依赖进行添加，删除，通知等操作</li></ul><h5 id="watcher类" tabindex="-1">Watcher类 <a class="header-anchor" href="#watcher类" aria-hidden="true">#</a></h5><blockquote><p>谁用到了数据，谁就是依赖，我们就为谁创建一个watcher实例，在之后数据变化时，我们不直接去通知依赖更新，而是通知依赖对应的<code>Watch</code>实例，由<code>Watcher</code>实例去通知真正的视图</p></blockquote><p><img src="http://songnian.gitee.io/imgs/imgs/watcher%E7%B1%BB%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" alt=""></p><h5 id="读流程" tabindex="-1">读流程 <a class="header-anchor" href="#读流程" aria-hidden="true">#</a></h5><ul><li><code>Data</code>通过<code>observer</code>转换成了<code>getter/setter</code>的形式来追踪变化。</li><li>当外界通过<code>Watcher</code>读取数据时，会触发<code>getter</code>从而将<code>Watcher</code>添加到依赖中。</li></ul><h5 id="写流程" tabindex="-1">写流程 <a class="header-anchor" href="#写流程" aria-hidden="true">#</a></h5><ul><li>当数据发生了变化时，会触发<code>setter</code>，从而向<code>Dep</code>中的依赖（即Watcher）发送通知。</li><li><code>Watcher</code>接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。</li></ul><h4 id="array的变化侦测" tabindex="-1">Array的变化侦测 <a class="header-anchor" href="#array的变化侦测" aria-hidden="true">#</a></h4><h5 id="收集依赖" tabindex="-1">收集依赖 <a class="header-anchor" href="#收集依赖" aria-hidden="true">#</a></h5><ul><li>数组的数据的依赖也在<code>getter</code>和<code>setter</code>中收集</li><li>在<code>defineReactive</code>函数中，首先获取数据对应的<code>Observer</code>实例<code>childOb</code>，然后在<code>getter</code>中调用<code>Observer</code>实例上依赖管理器，从而将依赖收集起来</li></ul><h5 id="拦截器" tabindex="-1">拦截器 <a class="header-anchor" href="#拦截器" aria-hidden="true">#</a></h5><blockquote><p>在<code>Vue</code>中创建了一个数组方法拦截器，它拦截在数组实例与<code>Array.prototype</code>之间，在拦截器内重写了操作数组的一些方法，比如可以通知变化等</p></blockquote><p><img src="http://songnian.gitee.io/imgs/imgs/%E6%8B%A6%E6%88%AA%E5%99%A8.png" alt=""></p><h5 id="通知依赖" tabindex="-1">通知依赖 <a class="header-anchor" href="#通知依赖" aria-hidden="true">#</a></h5><blockquote><p>我们应该在拦截器里通知依赖，要想通知依赖，首先要能访问到依赖</p><p>我们只要能访问到被转化成响应式的数据<code>value</code>即可</p><p><code>vaule</code>上的<code>__ob__</code>就是其对应的<code>Observer</code>类实例，有了<code>Observer</code>类实例我们就能访问到它上面的依赖管理器，然后只需调用依赖管理器的<code>dep.notify()</code>方法，让它去通知依赖更新即可</p></blockquote><h5 id="深度监测" tabindex="-1">深度监测 <a class="header-anchor" href="#深度监测" aria-hidden="true">#</a></h5><ul><li>对于<code>Array</code>型数据，调用了<code>observeArray()</code>方法，该方法内部会遍历数组中的每一个元素，然后通过调用<code>observe</code>函数将每一个元素都转化成可侦测的响应式数据</li></ul><h5 id="新增元素检测" tabindex="-1">新增元素检测 <a class="header-anchor" href="#新增元素检测" aria-hidden="true">#</a></h5><ul><li><p>如果向数组里新增一个元素的话，我们也需要将新增的这个元素转化成可侦测的响应式数据，操作是只需拿到新增的这个元素，然后调用<code>observe</code>函数将其转化即可</p></li><li><p>可以向数组内新增元素的方法有3个，分别是：<code>push</code>、<code>unshift</code>、<code>splice</code>，我们可以在这三个方法中分别处理即可</p></li></ul><h5 id="不足之处-vue-set和vue-delete来救" tabindex="-1">不足之处？Vue.set和Vue.delete来救 <a class="header-anchor" href="#不足之处-vue-set和vue-delete来救" aria-hidden="true">#</a></h5><blockquote><p>我们在日常开发中，还可以通过数组的下标来操作数据，而这样的修改是无法被拦截器侦测到的，为了解决这一问题，<code>Vue</code>增加了两个全局API:<code>Vue.set</code>和<code>Vue.delete</code></p></blockquote><h2 id="虚拟dom" tabindex="-1">虚拟DOM <a class="header-anchor" href="#虚拟dom" aria-hidden="true">#</a></h2><h4 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-hidden="true">#</a></h4><h5 id="什么是虚拟dom" tabindex="-1">什么是虚拟DOM？ <a class="header-anchor" href="#什么是虚拟dom" aria-hidden="true">#</a></h5><p>所谓虚拟DOM，就是用一个js中的对象来描述一个DOM节点</p><h5 id="为什么要有虚拟dom" tabindex="-1">为什么要有虚拟DOM？ <a class="header-anchor" href="#为什么要有虚拟dom" aria-hidden="true">#</a></h5><p>如果直接操作真实的DOM会非常耗时，因为一个真正的DOM是非常庞大的。我们可以利用计算时间来换取直接操作DOM所消耗的时间。即当数据发生变化时，可以比变化前后的虚拟DOM节点，通过<code>diff</code>算法来计算需要更新的地方</p><h4 id="vnode类" tabindex="-1">VNode类 <a class="header-anchor" href="#vnode类" aria-hidden="true">#</a></h4><blockquote><p>VNode类可以实例化出不同类型的虚拟DOM节点</p></blockquote><h5 id="vnode类内置变量-参数" tabindex="-1">VNode类内置变量（参数） <a class="header-anchor" href="#vnode类内置变量-参数" aria-hidden="true">#</a></h5><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">VNode</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">constructor</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#A6ACCD;font-style:italic;">tag</span><span style="color:#89DDFF;">?:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">,</span><span style="color:#676E95;font-style:italic;">//表示当前节点的标签名</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#A6ACCD;font-style:italic;">data</span><span style="color:#89DDFF;">?:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">VNodeData</span><span style="color:#89DDFF;">,</span><span style="color:#676E95;font-style:italic;">//VNodeData类型的数据</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#A6ACCD;font-style:italic;">children</span><span style="color:#89DDFF;">?:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">?</span><span style="color:#FFCB6B;">Array</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">VNode</span><span style="color:#89DDFF;">&gt;,</span><span style="color:#676E95;font-style:italic;">//子节点数组</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#A6ACCD;font-style:italic;">text</span><span style="color:#89DDFF;">?:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">,</span><span style="color:#676E95;font-style:italic;">//当前节点文本</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#A6ACCD;font-style:italic;">elm</span><span style="color:#89DDFF;">?:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Node</span><span style="color:#89DDFF;">,</span><span style="color:#676E95;font-style:italic;">//当前节点对应的真实DOM</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#A6ACCD;font-style:italic;">context</span><span style="color:#89DDFF;">?:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Component</span><span style="color:#89DDFF;">,</span><span style="color:#676E95;font-style:italic;">//当前组件节点对应的Vue实例</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#A6ACCD;font-style:italic;">componentOptions</span><span style="color:#89DDFF;">?:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">VNodeComponentOptions</span><span style="color:#89DDFF;">,</span><span style="color:#676E95;font-style:italic;">//当前组件的Option选项</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">asyncFactory</span><span style="color:#89DDFF;">?:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Function</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">tag</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">tag</span><span style="color:#F07178;">                                </span><span style="color:#676E95;font-style:italic;">/*当前节点的标签名*/</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">data</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">data</span><span style="color:#F07178;">        </span><span style="color:#676E95;font-style:italic;">/*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">children</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">children</span><span style="color:#F07178;">  </span><span style="color:#676E95;font-style:italic;">/*当前节点的子节点，是一个数组*/</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">text</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">text</span><span style="color:#F07178;">     </span><span style="color:#676E95;font-style:italic;">/*当前节点的文本*/</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">elm</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">elm</span><span style="color:#F07178;">       </span><span style="color:#676E95;font-style:italic;">/*当前虚拟节点对应的真实dom节点*/</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">ns</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">undefined</span><span style="color:#F07178;">            </span><span style="color:#676E95;font-style:italic;">/*当前节点的名字空间*/</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">context</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">context</span><span style="color:#F07178;">          </span><span style="color:#676E95;font-style:italic;">/*当前组件节点对应的Vue实例*/</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">fnContext</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">undefined</span><span style="color:#F07178;">       </span><span style="color:#676E95;font-style:italic;">/*函数式组件对应的Vue实例*/</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">fnOptions</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">undefined</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">fnScopeId</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">undefined</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">key</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">data</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">data</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">key</span><span style="color:#F07178;">           </span><span style="color:#676E95;font-style:italic;">/*节点的key属性，被当作节点的标志，用以优化*/</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">componentOptions</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">componentOptions</span><span style="color:#F07178;">   </span><span style="color:#676E95;font-style:italic;">/*组件的option选项*/</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">componentInstance</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">undefined</span><span style="color:#F07178;">       </span><span style="color:#676E95;font-style:italic;">/*当前节点对应的组件的实例*/</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">parent</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">undefined</span><span style="color:#F07178;">           </span><span style="color:#676E95;font-style:italic;">/*当前节点的父节点*/</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">raw</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">false</span><span style="color:#F07178;">         </span><span style="color:#676E95;font-style:italic;">/*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">isStatic</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">false</span><span style="color:#F07178;">         </span><span style="color:#676E95;font-style:italic;">/*静态节点标志*/</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">isRootInsert</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#F07178;">      </span><span style="color:#676E95;font-style:italic;">/*是否作为跟节点插入*/</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">isComment</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">false</span><span style="color:#F07178;">             </span><span style="color:#676E95;font-style:italic;">/*是否为注释节点*/</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">isCloned</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">false</span><span style="color:#F07178;">           </span><span style="color:#676E95;font-style:italic;">/*是否为克隆节点*/</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">isOnce</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">false</span><span style="color:#F07178;">                </span><span style="color:#676E95;font-style:italic;">/*是否有v-once指令*/</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">asyncFactory</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">asyncFactory</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">asyncMeta</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">undefined</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">isAsyncPlaceholder</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">false</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">get</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">child</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">():</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Component</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">componentInstance</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h5 id="vnode能够描述的节点类型" tabindex="-1">VNode能够描述的节点类型 <a class="header-anchor" href="#vnode能够描述的节点类型" aria-hidden="true">#</a></h5><ul><li><p>注释节点</p><ul><li>isComment：用于标识是否是注释节点</li><li>text：注释信息</li></ul></li><li><p>文本节点</p><ul><li>text：文本信息</li></ul></li><li><p>克隆节点</p><ul><li>复制一份已存在的节点，用于模板编译优化</li></ul></li><li><p>元素节点</p><blockquote><p>更贴近真实的DOM元素，有<code>tag</code>，<code>class</code>属性等</p></blockquote></li><li><p>组件节点</p><blockquote><p>相比于元素节点，有两个特殊的属性</p></blockquote><ul><li>componentOptions :组件的<code>option</code>选项，如组件的<code>props</code>等</li><li>componentInstance :当前组件节点对应的<code>Vue</code>实例</li></ul></li><li><p>函数式组件节点</p><blockquote><p>相比于元素节点，有两个特殊属性</p></blockquote><ul><li>fnContext:函数式组件对应的<code>Vue</code>实例</li><li>fnOptions: 组件的<code>option</code>选项</li></ul></li></ul><h5 id="vnode类的作用" tabindex="-1">VNode类的作用 <a class="header-anchor" href="#vnode类的作用" aria-hidden="true">#</a></h5><p>其实<code>VNode</code>的作用是相当大的。我们在视图渲染之前，把写好的<code>template</code>模板先编译成<code>VNode</code>并缓存下来，等到数据发生变化页面需要重新渲染的时候，我们把数据发生变化后生成的<code>VNode</code>与前一次缓存下来的<code>VNode</code>进行对比，找出差异，然后有差异的<code>VNode</code>对应的真实<code>DOM</code>节点就是需要重新渲染的节点，最后根据有差异的<code>VNode</code>创建出真实的<code>DOM</code>节点再插入到视图中，最终完成一次视图更新。</p><h4 id="dom-diff概论" tabindex="-1">DOM-Diff概论 <a class="header-anchor" href="#dom-diff概论" aria-hidden="true">#</a></h4><blockquote><p>找出前后虚拟DOM的差异过程就是DOM-diff过程</p></blockquote><h5 id="patch" tabindex="-1">Patch <a class="header-anchor" href="#patch" aria-hidden="true">#</a></h5><blockquote><p>在<code>Vue</code>中，把 <code>DOM-Diff</code>过程叫做<code>patch</code>过程，以新的VNode为基准，改造旧的oldVNode使之成为跟新的VNode一样</p></blockquote><h5 id="创建节点" tabindex="-1">创建节点 <a class="header-anchor" href="#创建节点" aria-hidden="true">#</a></h5><blockquote><p>创建节点是新的<code>VNode</code>有而旧的<code>VNode</code>没有。<code>VNode</code>类可以描述6种类型的节点，而实际上只有3种类型的节点能够被创建并插入到<code>DOM</code>中，它们分别是：元素节点、文本节点、注释节点</p></blockquote><p><img src="http://songnian.gitee.io/imgs/imgs/Patch%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9.png" alt=""></p><h5 id="删除节点" tabindex="-1">删除节点 <a class="header-anchor" href="#删除节点" aria-hidden="true">#</a></h5><blockquote><p>如果某些节点再新的<code>VNode</code>中没有而在旧的<code>VNode</code>中有，那么就需要把这些节点从旧的<code>VNode</code>中删除。删除节点非常简单，只需在要删除节点的父元素上调用<code>removeChild</code>方法即可</p></blockquote><h5 id="更新节点" tabindex="-1">更新节点 <a class="header-anchor" href="#更新节点" aria-hidden="true">#</a></h5><blockquote><p>更新节点就是当某些节点在新的<code>VNode</code>和旧的<code>VNode</code>中都有时，我们就需要细致比较一下，找出不一样的地方进行更新</p></blockquote><p><img src="http://songnian.gitee.io/imgs/imgs/Patch%E6%9B%B4%E6%96%B0%E8%8A%82%E7%82%B9.png" alt=""></p><h5 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h5><blockquote><p>整个<code>patchVnode</code>过程干了三件事，分别是：创建节点，删除节点，更新节点，其中更新子节点比较复杂</p></blockquote><h5 id="patch流程" tabindex="-1">patch流程 <a class="header-anchor" href="#patch流程" aria-hidden="true">#</a></h5><ul><li>首先使用<code>sameVnode</code>函数进行判断</li><li>如果不相同，则直接用新的<code>vnode</code>进行替换，直接渲染新的<code>vnode</code></li><li>如果相同，会使用<code>patchVnode</code>进一步比较，这里的目的是尽量复用多的节点</li></ul><h5 id="patchvnode流程" tabindex="-1">patchVnode流程 <a class="header-anchor" href="#patchvnode流程" aria-hidden="true">#</a></h5><blockquote><p>同级比较，不能跨级，文本节点和子节点是不会同时存在，以新<code>vnode</code>为基准</p></blockquote><ul><li>找到对应真实的<code>dom</code>，称为<code>el</code></li><li>如果新<code>vnode</code>和旧<code>vnode</code>指向一同个对象则直接返回</li><li>如果新旧<code>vnode</code>都有本文节点并且不相等，那么<code>el</code>的本文节点将替换成<code>vnode</code>的文本节点</li><li>如果新的<code>vnode</code>没有子节点，而旧的<code>vnode</code>有子节点，则删除<code>el</code>的子节点</li><li>如果新的<code>vnode</code>有子节点，而旧的<code>vnode</code>没有子节点，则添加<code>vnode</code>子节点真实化后添加到<code>el</code></li><li>如果两者都有子节点，则执行<code>updateChildren</code>函数进一步比较子节点</li></ul><h5 id="updatechildren流程" tabindex="-1">updateChildren流程 <a class="header-anchor" href="#updatechildren流程" aria-hidden="true">#</a></h5><blockquote><p>一层一层地递归比较</p></blockquote><ul><li>将新的<code>vnode</code>的子节点和旧的<code>vnode</code>的子节点取出来</li><li>新的<code>vnode</code>的子节点和旧的<code>vnode</code>的子节点各有两个头尾指针<code>StartIdx</code>和<code>endIdx</code>，也有说他们是(新前，新后，旧前，旧后)，他们之间有4种比较，如果当中两个匹配得上，则真实DOM的相应节点会移动到新<code>vnode</code>的位置，随后指针进行移动，那么一般最后有两个结果： <ul><li>如果旧前指针大于旧后指针，说明旧的<code>vnode</code>先遍历完了，那么剩下的多出的新的<code>vnode</code>就会根据<code>index</code>自动插入到真实<code>DOM</code>中</li><li>如果新前指针大于新后指针，说明新的<code>vnode</code>先遍历完了，那么就会在真实<code>DOM</code>中删除旧前和旧后这个区间内的多余节点</li></ul></li><li>如果上述4种比较都没有匹配到，就会用<code>key</code>进行比较： <ul><li>如果没有<code>key</code>，则直接将指向新的<code>vnode</code>的子节点，插入真实<code>DOM</code></li><li>如果有<code>key</code>，旧的<code>vnode</code>的子节点会根据<code>key</code>生成一个<code>hash</code>表，遍历新的<code>vode</code>的子节点，让它<code>key</code>与<code>hash</code>表进行匹配，匹配成功后会进行相应的更新处理</li></ul></li></ul>`,66),p=[l];function c(t,r,d,i,y,F){return o(),e("div",null,p)}const C=s(n,[["render",c]]);export{h as __pageData,C as default};
