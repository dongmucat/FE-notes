import{_ as e,c as a,o as d,a as i}from"./app.756a2891.js";const m=JSON.parse('{"title":"Vue面试","description":"","frontmatter":{},"headers":[{"level":2,"title":"Vue工作原理","slug":"vue工作原理","link":"#vue工作原理","children":[]},{"level":2,"title":"Vue双向数据绑定原理","slug":"vue双向数据绑定原理","link":"#vue双向数据绑定原理","children":[]},{"level":2,"title":"Vue模板编译原理(简)","slug":"vue模板编译原理-简","link":"#vue模板编译原理-简","children":[]},{"level":2,"title":"Vue2生命周期","slug":"vue2生命周期","link":"#vue2生命周期","children":[]},{"level":2,"title":"Vue3生命周期","slug":"vue3生命周期","link":"#vue3生命周期","children":[]},{"level":2,"title":"v-model原理","slug":"v-model原理","link":"#v-model原理","children":[]},{"level":2,"title":"Vue.nextTick的理解","slug":"vue-nexttick的理解","link":"#vue-nexttick的理解","children":[]},{"level":2,"title":"什么是MVVM？","slug":"什么是mvvm","link":"#什么是mvvm","children":[]},{"level":2,"title":"什么是MVC？","slug":"什么是mvc","link":"#什么是mvc","children":[]},{"level":2,"title":"Vue为什么没有完全遵守MVVM?","slug":"vue为什么没有完全遵守mvvm","link":"#vue为什么没有完全遵守mvvm","children":[]},{"level":2,"title":"computed与watch区别","slug":"computed与watch区别","link":"#computed与watch区别","children":[]},{"level":2,"title":"computed与methods区别","slug":"computed与methods区别","link":"#computed与methods区别","children":[]},{"level":2,"title":"v-for中的key","slug":"v-for中的key","link":"#v-for中的key","children":[]},{"level":2,"title":"为什么不建议使用index","slug":"为什么不建议使用index","link":"#为什么不建议使用index","children":[]},{"level":2,"title":"v-if和v-show区别","slug":"v-if和v-show区别","link":"#v-if和v-show区别","children":[]},{"level":2,"title":"data为什么不是一个对象而是一个函数？","slug":"data为什么不是一个对象而是一个函数","link":"#data为什么不是一个对象而是一个函数","children":[]},{"level":2,"title":"SPA和MPA的区别","slug":"spa和mpa的区别","link":"#spa和mpa的区别","children":[]},{"level":2,"title":"Vue2组件通信","slug":"vue2组件通信","link":"#vue2组件通信","children":[]},{"level":2,"title":"Vuex","slug":"vuex-1","link":"#vuex-1","children":[]},{"level":2,"title":"Vue-Router","slug":"vue-router","link":"#vue-router","children":[]}],"relativePath":"guide/Vue面试.md","lastUpdated":1673594167000}'),t={name:"guide/Vue面试.md"},r=i('<h1 id="vue面试" tabindex="-1">Vue面试 <a class="header-anchor" href="#vue面试" aria-hidden="true">#</a></h1><h2 id="vue工作原理" tabindex="-1">Vue工作原理 <a class="header-anchor" href="#vue工作原理" aria-hidden="true">#</a></h2><p>首先当一个Vue实例被创建的时候，Vue会遍历data中的属性，通过<code>Observer</code>类来转换成<code>getter/setter</code>的形式来追踪变化，当外界通过<code>Watcher</code>读取数据时，会触发<code>getter</code>从而<code>Dep</code>会将<code>Watcher</code>添加到依赖中，当数据发生了变化时候，会触发<code>setter</code>，从而向<code>Dep</code>中的依赖，也就是<code>Watcher</code>发送通知，<code>Watcher</code>接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新</p><h2 id="vue双向数据绑定原理" tabindex="-1">Vue双向数据绑定原理 <a class="header-anchor" href="#vue双向数据绑定原理" aria-hidden="true">#</a></h2><h4 id="原理图" tabindex="-1">原理图 <a class="header-anchor" href="#原理图" aria-hidden="true">#</a></h4><p><img src="http://songnian.gitee.io/imgs/imgs/Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86.png" alt=""></p><h4 id="初始化阶段" tabindex="-1">初始化阶段 <a class="header-anchor" href="#初始化阶段" aria-hidden="true">#</a></h4><ul><li>第一个是数据监听，<code>Vue</code>会遍历<code>data</code>中的属性，通过<code>Observer</code>类来转换成<code>getter/setter</code>的形式来追踪变化</li><li>第二是页面渲染，<code>Compile</code>解析模板指令，将模板中的指令替换成数据，然后初始化视图，并订阅<code>Watcher</code>来更新视图，此时<code>Watcher</code>会将自己添加到<code>Dep</code>中</li></ul><h4 id="数据更新阶段" tabindex="-1">数据更新阶段 <a class="header-anchor" href="#数据更新阶段" aria-hidden="true">#</a></h4><p>当数据发生变化的时候，会触发<code>Obersever</code>的<code>setter</code>，从而<code>Dep</code>会调用<code>notify</code>方法遍历通知所有的<code>Watcher</code>，<code>Watcher</code>收到通知后，也会对视图进行相应的更新</p><h2 id="vue模板编译原理-简" tabindex="-1">Vue模板编译原理(简) <a class="header-anchor" href="#vue模板编译原理-简" aria-hidden="true">#</a></h2><blockquote><p>Vue需要将template转换成js的函数，这样浏览器可以执行这个函数并渲染出HTML元素。这个过程可以简要分为三个阶段：解析，优化，生成</p></blockquote><ul><li>解析阶段：使用大量的正则表达式对template字符串进行解析，转化成抽象语法树AST</li><li>优化阶段：遍历AST，找到一些静态节点，等到下一次重新渲染的时候直接跳过，优化性能</li><li>生成阶段：最终的AST转化成render</li></ul><h2 id="vue2生命周期" tabindex="-1">Vue2生命周期 <a class="header-anchor" href="#vue2生命周期" aria-hidden="true">#</a></h2><blockquote><p>实际上有四个类，初始化，挂载，更新，摧毁</p></blockquote><ul><li>beforeCreated：一个组件创建的开始，这个时候data、methods、computed、watch都不能用</li><li>Created：组件实例已经完全创建，这个时候一般用于向后端获取数据</li><li>beforeMount：表示当前虚拟DOM已经创建完成，但是还没有挂载</li><li>mounted：表示挂载完成，此时可以访问到真实DOM</li><li>beforeUpdate：组件数据更新之前调用， 此时页面中显示的数据还是旧的，但 data 是最新的，页面尚未和最新的数据保持同步</li><li>update：组件数据更新之后，此时页面和data中的数据都已经保持了同步</li><li>beforeDestroy：组件销毁前调用，此时实例上的数据都还保持正常使用</li><li>destroyed：组件销毁后调用，此时实例上的东西都不能用了</li></ul><h2 id="vue3生命周期" tabindex="-1">Vue3生命周期 <a class="header-anchor" href="#vue3生命周期" aria-hidden="true">#</a></h2><blockquote><p>Vue3能兼容vue2的生命周期，但在写composition api的时候钩子的名字会发生一点变化</p></blockquote><p>被替换</p><ul><li>beforeCreate -&gt; setup()</li><li>created -&gt; setup()</li></ul><p>重命名</p><ul><li>beforeMount -&gt; onBeforeMount</li><li>mounted -&gt; onMounted</li><li>beforeUpdate -&gt; onBeforeUpdate</li><li>updated -&gt; onUpdated</li><li>beforeDestroy -&gt; <strong>onBeforeUnmount</strong></li><li>destroyed -&gt; <strong>onUnmounted</strong></li></ul><h2 id="v-model原理" tabindex="-1">v-model原理 <a class="header-anchor" href="#v-model原理" aria-hidden="true">#</a></h2><p>实际上<code>v-model</code>是一个语法糖，他做了单向绑定数据<code>v-bind</code>和触发输入事件<code>input</code></p><h2 id="vue-nexttick的理解" tabindex="-1">Vue.nextTick的理解 <a class="header-anchor" href="#vue-nexttick的理解" aria-hidden="true">#</a></h2><p>如果想要在修改数据后立刻得到更新后的<code>DOM</code>结构，可以使用<code>Vue.nextTick()</code>，因为<code>Vue</code>更新<code>DOM</code>是一个异步操作，它有一个队列，需要等待所有的数据都变化完成之后再统一进行更新</p><h2 id="什么是mvvm" tabindex="-1">什么是MVVM？ <a class="header-anchor" href="#什么是mvvm" aria-hidden="true">#</a></h2><h4 id="原理图-1" tabindex="-1">原理图 <a class="header-anchor" href="#原理图-1" aria-hidden="true">#</a></h4><p><img src="http://songnian.gitee.io/imgs/imgs/MVVM.png" alt=""></p><h4 id="含义" tabindex="-1">含义 <a class="header-anchor" href="#含义" aria-hidden="true">#</a></h4><ul><li>M：Model，对应数据层的模型</li><li>V：View，对应视图UI模型</li><li>VM：ViewModel，一个抽象层，可以将Model和View连接了起来，实现了通信</li></ul><h4 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-hidden="true">#</a></h4><ul><li>低耦合：View和Model都可以独立于对方的变化和修改</li><li>可复用性：一个ViewModel里面的视图逻辑可以让很多个View使用</li><li>独立开发：开发人员专注于ViewModel开发，设计人员可以专注于UI开发</li><li>方便测试：可以方便对ViewModel进行测试</li></ul><h2 id="什么是mvc" tabindex="-1">什么是MVC？ <a class="header-anchor" href="#什么是mvc" aria-hidden="true">#</a></h2><h4 id="原理图-2" tabindex="-1">原理图 <a class="header-anchor" href="#原理图-2" aria-hidden="true">#</a></h4><p><img src="http://songnian.gitee.io/imgs/imgs/MVC.png" alt=""></p><h4 id="含义-1" tabindex="-1">含义 <a class="header-anchor" href="#含义-1" aria-hidden="true">#</a></h4><ul><li>M：Model，是应用程序中用于处理应用程序数据逻辑的部分</li><li>V：View，是应用程序中处理数据显示的部分</li><li>C：Controller，是应用程序中处理用户交互的部分，从View读取数据，向Model发送数据</li></ul><h4 id="优点-1" tabindex="-1">优点 <a class="header-anchor" href="#优点-1" aria-hidden="true">#</a></h4><ul><li>低耦合性</li><li>可复用性高</li><li>部署快</li><li>可维护性高</li><li>有利于软件工程化</li></ul><h2 id="vue为什么没有完全遵守mvvm" tabindex="-1">Vue为什么没有完全遵守MVVM? <a class="header-anchor" href="#vue为什么没有完全遵守mvvm" aria-hidden="true">#</a></h2><ul><li>MVVM模型中的Model层和View层应该是解耦的，但是有ref这个属性可以拿到DOM，这一点打破了这个原则</li><li>Vue中的VM中包含着Model数据层，在我看来，这两部分没有独立出来</li></ul><h2 id="computed与watch区别" tabindex="-1">computed与watch区别 <a class="header-anchor" href="#computed与watch区别" aria-hidden="true">#</a></h2><ul><li>computed是计算属性，而watch用于监听属性发生变化</li><li>computed不支持异步，而watch支持异步</li><li>computed有缓存而watch没有缓存</li><li>computed必须要有返回值且默认第一次就进行计算，watch可以没有返回值并且默认第一次加载不会做监听，除非加上immediate设置为true</li></ul><h2 id="computed与methods区别" tabindex="-1">computed与methods区别 <a class="header-anchor" href="#computed与methods区别" aria-hidden="true">#</a></h2><ul><li>computed是计算属性依赖于属性，而methods是函数，两者其实不同</li><li>computed有缓存，多次使用只调用一次，而methods使用n次就会调用n次</li></ul><h2 id="v-for中的key" tabindex="-1">v-for中的key <a class="header-anchor" href="#v-for中的key" aria-hidden="true">#</a></h2><h4 id="key的作用" tabindex="-1">key的作用 <a class="header-anchor" href="#key的作用" aria-hidden="true">#</a></h4><p>v-for默认使用就地复用的策略，当列表数据修改的时候，vue会根据key来判断节点如何进行复用或者重新渲染，因此key主要用于提高渲染速度</p><h2 id="为什么不建议使用index" tabindex="-1">为什么不建议使用index <a class="header-anchor" href="#为什么不建议使用index" aria-hidden="true">#</a></h2><p>index不是唯一标识，因此会导致DOM渲染速度降低，而且会出现复用错误的情况。因此最好用唯一标识符做key</p><h2 id="v-if和v-show区别" tabindex="-1">v-if和v-show区别 <a class="header-anchor" href="#v-if和v-show区别" aria-hidden="true">#</a></h2><ul><li><p>v-if会根据条件去渲染DOM，是惰性的；而v-show都会去渲染DOM，v-show只是简单的控制了一下css的display</p></li><li><p>v-show更适合频繁切换的场景；v-if适合比较少的切换场景</p></li></ul><h2 id="data为什么不是一个对象而是一个函数" tabindex="-1">data为什么不是一个对象而是一个函数？ <a class="header-anchor" href="#data为什么不是一个对象而是一个函数" aria-hidden="true">#</a></h2><p>如果是对象的话，当组件复用的时候 ，指向的都是是一个内存地址 ， 当其中一个组件修改data的数据时 ， 其他的组件中的data数据也会被修改 。 如果是函数的话 , 每次生成的就是一个新的副本 ，那么就不会出现这个问题</p><h2 id="spa和mpa的区别" tabindex="-1">SPA和MPA的区别 <a class="header-anchor" href="#spa和mpa的区别" aria-hidden="true">#</a></h2><ul><li>SPA是单页面应用，是一个主页面和多个组件组成，一开始只需要加载一次资源，所有的内容都包含在主页面，因此跳转就是切换对应的组件，速度很快，仅仅刷新局部资源。缺点就是首屏加载时间可能会长，还有不利于SEO</li><li>MPA是多页面应用，由多个页面组成，每个页面必须重新重复地加载资源，因此跳转速度比较慢，体验可能会不好，优点是利于SEO</li></ul><h2 id="vue2组件通信" tabindex="-1">Vue2组件通信 <a class="header-anchor" href="#vue2组件通信" aria-hidden="true">#</a></h2><h4 id="父子通信" tabindex="-1">父子通信 <a class="header-anchor" href="#父子通信" aria-hidden="true">#</a></h4><h5 id="props" tabindex="-1">props <a class="header-anchor" href="#props" aria-hidden="true">#</a></h5><ul><li>用于父组件向子组件传送数据，这是最常用的了，可以接收<code>v-model</code>、<code>name.sync</code></li></ul><h5 id="ref" tabindex="-1">ref <a class="header-anchor" href="#ref" aria-hidden="true">#</a></h5><ul><li><code>ref</code>作用在子组件上的时候，引用的指向就是子组件，然后父组件可以通过<code>this.$refs</code>拿到子组件</li></ul><h5 id="children-parent" tabindex="-1">$children / $parent <a class="header-anchor" href="#children-parent" aria-hidden="true">#</a></h5><ul><li><p>父组件可以拿到<code>children </code>来获取它所有的子组件</p></li><li><p>子组件可以拿到<code>parent</code>来获取它的父组件</p></li></ul><h5 id="slot" tabindex="-1">slot <a class="header-anchor" href="#slot" aria-hidden="true">#</a></h5><ul><li>利用<code>slot</code>，父组件可以向子组件传参</li></ul><h5 id="自定义事件" tabindex="-1">自定义事件 <a class="header-anchor" href="#自定义事件" aria-hidden="true">#</a></h5><ul><li>父组件在子组件上自定义一个事件，子组件通过$emit触发事件，回调给父组件，父组件就可以接收到数据</li></ul><h4 id="跨层级通信" tabindex="-1">跨层级通信 <a class="header-anchor" href="#跨层级通信" aria-hidden="true">#</a></h4><h5 id="vuex" tabindex="-1">Vuex <a class="header-anchor" href="#vuex" aria-hidden="true">#</a></h5><p>使用<code>Vuex</code>可以管理所有组件依赖的状态</p><h5 id="eventbus" tabindex="-1">EventBus <a class="header-anchor" href="#eventbus" aria-hidden="true">#</a></h5><p><code>EventBus</code>是中央事件总线，<code>Vue</code>官方也有说使用一个<code>Vue</code>实例来作为中央事件总线，也是依靠<code>$emit</code>和<code>$on</code>之类的</p><h2 id="vuex-1" tabindex="-1">Vuex <a class="header-anchor" href="#vuex-1" aria-hidden="true">#</a></h2><blockquote><p>Vuex是一个状态管理库，可以管理多个组件依赖的状态</p></blockquote><p><img src="http://songnian.gitee.io/imgs/imgs/vuex.png" alt=""></p><h4 id="基本参数" tabindex="-1">基本参数 <a class="header-anchor" href="#基本参数" aria-hidden="true">#</a></h4><ul><li>store：实际上就是管理数据的仓库</li><li>state：用于存放数据</li><li>actions：可以实现异步操作，用于提交到mutation</li><li>mutations：用于更改数据，不支持异步操作</li><li>getter：相当于computed，是由state派生出的状态</li></ul><h4 id="基本使用流程" tabindex="-1">基本使用流程 <a class="header-anchor" href="#基本使用流程" aria-hidden="true">#</a></h4><ul><li>在vue组件中通过dispatch提交到actions，然后在actions通过commit提交到mutations，mutations最后进行数据的更改，然后依赖组件再进行渲染</li><li>可以使用mapActions、mapState、mapMutations工具开发更舒服</li></ul><h2 id="vue-router" tabindex="-1">Vue-Router <a class="header-anchor" href="#vue-router" aria-hidden="true">#</a></h2><blockquote><p>Vue-Router的最大作用就是跳转到相应的组件</p></blockquote><h4 id="懒加载实现" tabindex="-1">懒加载实现 <a class="header-anchor" href="#懒加载实现" aria-hidden="true">#</a></h4><ul><li>使用箭头函数+import动态加载</li></ul><h4 id="hash模式" tabindex="-1">hash模式 <a class="header-anchor" href="#hash模式" aria-hidden="true">#</a></h4><p><strong>特点</strong>：hash模式的时候URL会有一个**#**符号，hash就是在这个符号后面，hash值会出现在URL里，但是不会出现在HTTP请求中。改变hash值不会重新加载页面</p><p><strong>原理</strong>：原理就是利用了<code>window.onhashchange</code>事件，通过这个事件来监听URL的变化，利用<code>location.hash</code>获取到hash值，然后再来处理相关的逻辑操作</p><h4 id="history模式" tabindex="-1">history模式 <a class="header-anchor" href="#history模式" aria-hidden="true">#</a></h4><p><strong>特点</strong>：history模式的时候没有**#**，它是传统的模式，也就是说我们输入URL的时候，服务器会接收这个URL，然后要解析才能做出相应的逻辑处理。history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404</p><p><strong>原理</strong>：history利用了<code>pushState()</code>和<code>replaceState()</code>两个方法，<strong>这两个方法改变 URL 的 path 部分不会引起页面刷新</strong></p><h4 id="api跳转区别" tabindex="-1">api跳转区别 <a class="header-anchor" href="#api跳转区别" aria-hidden="true">#</a></h4><table><thead><tr><th>api</th><th>hash</th><th>history</th></tr></thead><tbody><tr><td><strong>push</strong></td><td><strong>window.location.assign</strong></td><td><strong>window.history.pushState</strong></td></tr><tr><td><strong>replace</strong></td><td><strong>window.location.replace</strong></td><td><strong>window.history.replaceState</strong></td></tr><tr><td>go、back、forward</td><td>window.history.go</td><td>window.history.go</td></tr></tbody></table><h4 id="路由守卫" tabindex="-1">路由守卫 <a class="header-anchor" href="#路由守卫" aria-hidden="true">#</a></h4><ul><li>全局守卫/钩子：<code>beforeEach</code>、<code>beforeResolve</code>、<code>afterEach</code></li><li>路由独享的守卫：<code>beforeEnter</code></li><li>组件内的守卫：<code>beforeRouteEnter</code>、<code>beforeRouteUpdate</code>、<code>beforeRouteLeave</code></li></ul><h4 id="vue-router中的组件" tabindex="-1">Vue-Router中的组件 <a class="header-anchor" href="#vue-router中的组件" aria-hidden="true">#</a></h4><ul><li><code>&lt;router-link/&gt;</code>：用于跳转到目标地址，还可以携带参数，实际上是通过<code>&lt;a&gt;</code>标签实现的</li><li><code>&lt;router-view/&gt;</code>：用于渲染路由要跳转的页面</li><li><code>&lt;keep-alive/&gt;</code>：用于缓存需要缓存的组件，比如可以切出去再切回来的时候数据还在</li></ul>',97),l=[r];function o(h,c,n,u,s,p){return d(),a("div",null,l)}const f=e(t,[["render",o]]);export{m as __pageData,f as default};
