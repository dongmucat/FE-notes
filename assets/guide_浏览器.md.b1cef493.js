import{_ as s,c as a,o,a as e}from"./app.ed024433.js";const h=JSON.parse('{"title":"浏览器","description":"","frontmatter":{},"headers":[{"level":2,"title":"浏览器解析HTML过程","slug":"浏览器解析html过程","link":"#浏览器解析html过程","children":[]},{"level":2,"title":"async defer 区别","slug":"async-defer-区别","link":"#async-defer-区别","children":[]},{"level":2,"title":"cookie sessionStorage localStorage 区别","slug":"cookie-sessionstorage-localstorage-区别","link":"#cookie-sessionstorage-localstorage-区别","children":[{"level":3,"title":"cookie session 区别","slug":"cookie-session-区别","link":"#cookie-session-区别","children":[]},{"level":3,"title":"session token 区别","slug":"session-token-区别","link":"#session-token-区别","children":[]}]},{"level":2,"title":"重排和重绘","slug":"重排和重绘","link":"#重排和重绘","children":[]},{"level":2,"title":"白屏与首屏","slug":"白屏与首屏","link":"#白屏与首屏","children":[]},{"level":2,"title":"客户端渲染(CSR)与服务端渲染(SSR)","slug":"客户端渲染-csr-与服务端渲染-ssr","link":"#客户端渲染-csr-与服务端渲染-ssr","children":[]},{"level":2,"title":"浏览器有哪些进程？","slug":"浏览器有哪些进程","link":"#浏览器有哪些进程","children":[]},{"level":2,"title":"js在V8中的执行过程","slug":"js在v8中的执行过程","link":"#js在v8中的执行过程","children":[]}],"relativePath":"guide/浏览器.md","lastUpdated":1673594167000}'),n={name:"guide/浏览器.md"},l=e(`<h1 id="浏览器" tabindex="-1">浏览器 <a class="header-anchor" href="#浏览器" aria-hidden="true">#</a></h1><h2 id="浏览器解析html过程" tabindex="-1">浏览器解析HTML过程 <a class="header-anchor" href="#浏览器解析html过程" aria-hidden="true">#</a></h2><h4 id="domcontentloaded" tabindex="-1">DOMContentLoaded <a class="header-anchor" href="#domcontentloaded" aria-hidden="true">#</a></h4><blockquote><p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载</p></blockquote><h4 id="load" tabindex="-1">load <a class="header-anchor" href="#load" aria-hidden="true">#</a></h4><blockquote><p>当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件</p></blockquote><h4 id="case1-无js-无css" tabindex="-1">case1：无JS，无CSS <a class="header-anchor" href="#case1-无js-无css" aria-hidden="true">#</a></h4><p><img src="http://songnian.gitee.io/imgs/imgs/HTML%E8%A7%A3%E6%9E%901.png" alt=""></p><h4 id="case2-无js-有css" tabindex="-1">case2：无JS，有CSS <a class="header-anchor" href="#case2-无js-有css" aria-hidden="true">#</a></h4><blockquote><p>在这个情况的时候，CSS不会阻碍DOM的解析，但是会阻碍DOM的渲染</p></blockquote><p><img src="http://songnian.gitee.io/imgs/imgs/HTML%E8%A7%A3%E6%9E%902.png" alt=""></p><h4 id="case3-有js-有css" tabindex="-1">case3：有JS，有CSS <a class="header-anchor" href="#case3-有js-有css" aria-hidden="true">#</a></h4><ul><li>JS脚本会阻碍DOM解析</li><li>CSS会阻碍JS脚本执行，因此也会间接阻碍DOM解析</li><li>CSS必定会阻碍DOM渲染</li></ul><p><img src="http://songnian.gitee.io/imgs/imgs/HTML%E8%A7%A3%E6%9E%903.png" alt=""></p><h2 id="async-defer-区别" tabindex="-1">async defer 区别 <a class="header-anchor" href="#async-defer-区别" aria-hidden="true">#</a></h2><blockquote><p>DOMContentLoaded事件不一定就是DOM解析完成的事件</p></blockquote><ul><li><code>async</code>是异步执行，此处的<code>DOMcontentLoaded</code>事件触发只关注<code>DOM</code>是否被解析完，与<code>async</code>无关。异步下载完毕后就马上执行，因此可能会阻塞<code>DOM</code>解析，浏览器并不能保证多个<code>async</code>脚本按顺序执行。总的来说执行时机一定在<code>load</code>事件之前，可能在<code>DOMcontentLoaded</code>事件之前或者之后</li><li><code>defer</code>是延迟执行，此处的<code>DOMcontentLoaded</code>事件触发是要<code>defer</code>脚本执行完毕后才会触发，<code>defer</code>的执行时机是在<code>DOMcontentLoaded</code>事件之前，换个一个角度说就是<code>defer</code>会等待真正的<code>DOM</code>解析完之后执行，所以它不会阻碍<code>DOM</code>解析，并且多个<code>defer</code>脚本执行可以按顺序执行</li><li><strong>区别就在于DOMContentLoaded事件的触发时间点</strong></li></ul><h2 id="cookie-sessionstorage-localstorage-区别" tabindex="-1">cookie sessionStorage localStorage 区别 <a class="header-anchor" href="#cookie-sessionstorage-localstorage-区别" aria-hidden="true">#</a></h2><blockquote><p>共同点是都存储在客户端，且都是同源的</p></blockquote><ul><li>生命周期不同：<code>cookie</code>一般由服务器生成，可以设置失效时间，如果是在自己浏览器生成的话，默认是关闭后会失效；<code>sessionStorage</code>关闭标签页或者浏览器就会失效；<code>localStorage</code>除非被清除，否则一直是有效的</li><li>作用域不同：<code>cookie</code>和<code>localStorage</code>在所有的同源窗口都是共享的，而<code>sessionStorage</code>不能共享</li><li>大小不同：<code>cookie</code>大小一般不超过<strong>4k</strong>，<code>sessionStorage </code>和<code>localStorage</code>可以到<strong>5M</strong></li><li>是否与服务端通信：<code>cookie</code>数据始终在同源的请求中携带，再浏览器和服务器之间来回传递；而<code>sessionStorage </code>和<code>localStorage</code>不会自动把数据发给浏览器，仅在本地保存</li></ul><h3 id="cookie-session-区别" tabindex="-1">cookie session 区别 <a class="header-anchor" href="#cookie-session-区别" aria-hidden="true">#</a></h3><ul><li>存储位置不同：<code>cookie</code>存储在客户端，<code>session</code>存储在服务端，因此<code>session</code>也会更安全一些</li><li>存储大小不同：<code>cookie</code>大小一般不超过<strong>4k</strong>，而<code>session</code>要大得多，但是<code>session</code>太多太大的话会造成服务器的压力</li><li>有效期不同：<code>cookie</code>一般有效期较长，<code>session</code>有效期一般较短</li></ul><h3 id="session-token-区别" tabindex="-1">session token 区别 <a class="header-anchor" href="#session-token-区别" aria-hidden="true">#</a></h3><ul><li>服务端是有记录状态：<code>session</code>记录了客户端和服务器的会话状态，而<code>token</code>是令牌，是一种访问资源的一种凭证，它可以使得服务器无状态化，不需要存储会话信息，它用计算来代替了储存</li><li><code>token</code>的安全性更好一些，因为每个<code>token</code>还有签名，可以防止监听，而<code>session</code>需要依靠链路层来保证安全性了</li></ul><h2 id="重排和重绘" tabindex="-1">重排和重绘 <a class="header-anchor" href="#重排和重绘" aria-hidden="true">#</a></h2><h4 id="解释" tabindex="-1">解释 <a class="header-anchor" href="#解释" aria-hidden="true">#</a></h4><ul><li><p>重排和重绘其实是发生在浏览器渲染路径上的两个节点。浏览器最关键的渲染路径就是<code>DOM</code>和<code>CSSOM</code>生成渲染树(<code>render tree</code>)，然后渲染树<code>render tree</code>通过布局(<code>layout</code>)来确定页面所有的内容的大小与位置，确定布局后，就进行<code>paint</code>操作，也就是把像素绘制到屏幕上</p></li><li><p>其中重排就是当元素的位置和大小发生变动的时候，浏览器就要重新执行布局这个步骤，来重新确定页面所有内容的大小和位置，然后再重新绘制到屏幕上，所以重排一定会导致重绘</p></li><li><p>其中重绘就是当元素的位置和大小没有发生变动，而仅仅是样式发生变动的时候，浏览器就会跳过布局(<code>layout</code>)步骤而直接执行绘制(<code>paint</code>)这个步骤，所以重绘不一定会导致重排</p></li></ul><h4 id="如何减少重排和重绘" tabindex="-1">如何减少重排和重绘？ <a class="header-anchor" href="#如何减少重排和重绘" aria-hidden="true">#</a></h4><ul><li>集中式改变样式，不要频繁的进行样式的改变</li><li>分离读和写操作，读操作的时候可以用变量进行缓存</li><li>尽量少使用<code>dispaly:none</code>，可以使用<code>visibility:hidden</code>代替，<code>dispaly:none</code>会造成重排和重绘，<code>visibility:hidden</code>只会造成重绘。</li><li>不要使用<code>Table</code>布局，因为一个小小的操作，可能就会造成整个表格的重排或者重绘</li><li>批量修改元素时，可以先让元素脱离文档流，等修改完毕后，再放入文档流</li></ul><h2 id="白屏与首屏" tabindex="-1">白屏与首屏 <a class="header-anchor" href="#白屏与首屏" aria-hidden="true">#</a></h2><h4 id="白屏" tabindex="-1">白屏 <a class="header-anchor" href="#白屏" aria-hidden="true">#</a></h4><p>白屏时间是指浏览器开始显示内容的时间。一般认为是解析完<code>&lt;head&gt;</code>的时刻为白屏时间</p><p><strong>计算：</strong></p><p>在 <code>&lt;head&gt; </code>标签前的<code>&lt;script&gt; </code>标签内加入代码：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Date</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getTime</span><span style="color:#A6ACCD;">() </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> performance</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">timing</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">navigationStart)</span></span>
<span class="line"></span></code></pre></div><h4 id="首屏" tabindex="-1">首屏 <a class="header-anchor" href="#首屏" aria-hidden="true">#</a></h4><p>首屏时间是指用户打开网站开始，到浏览器首屏内容渲染完成的时间</p><p><strong>计算：</strong></p><p>再<code>&lt;body&gt;</code>下方的<code>&lt;script&gt; </code>标签加入代码：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Date</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getTime</span><span style="color:#A6ACCD;">() </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> performance</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">timing</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">navigationStart)</span></span>
<span class="line"></span></code></pre></div><h4 id="优化" tabindex="-1">优化 <a class="header-anchor" href="#优化" aria-hidden="true">#</a></h4><ul><li>减少HTTP请求次数，减少HTTP请求大小</li><li>合并压缩文件(gzip)</li><li>采用svg图片或者字体图标</li><li>尽量将 CSS 放文件头部，JS 文件放在底部，也可以是用defer加载JS</li><li>采用服务端渲染</li><li>CDN</li><li>资源缓存</li><li>图片懒加载</li></ul><h2 id="客户端渲染-csr-与服务端渲染-ssr" tabindex="-1">客户端渲染(CSR)与服务端渲染(SSR) <a class="header-anchor" href="#客户端渲染-csr-与服务端渲染-ssr" aria-hidden="true">#</a></h2><h4 id="客户端渲染-client-side-rendering" tabindex="-1">客户端渲染(Client-side rendering) <a class="header-anchor" href="#客户端渲染-client-side-rendering" aria-hidden="true">#</a></h4><p>从服务端获取<code>HTML</code>文件，服务端不会对文件进行任何的处理，客户端需要自行下载和执行<code>javascript</code>，生成<code>DOM</code>然后再渲染</p><h5 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-hidden="true">#</a></h5><p>前后端分离，减少服务端压力，局部刷新</p><h5 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-hidden="true">#</a></h5><p>不利于SEO，首屏渲染慢</p><h4 id="服务端渲染-server-side-rendering" tabindex="-1">服务端渲染(Server-side rendering) <a class="header-anchor" href="#服务端渲染-server-side-rendering" aria-hidden="true">#</a></h4><blockquote><p>可能实际上很多网站是处于经济效益的考虑，主要是SEO和首屏</p></blockquote><p>服务端返回<code>渲染好的HTML</code>文件，客户端不需要做任何操作，直接呈现就可以</p><h5 id="优点-1" tabindex="-1">优点 <a class="header-anchor" href="#优点-1" aria-hidden="true">#</a></h5><p>利于SEO，首屏渲染速度快</p><h5 id="缺点-1" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-1" aria-hidden="true">#</a></h5><p>服务端压力大，前后端不分离不容易维护，前端页面更改，后端也要更改</p><h2 id="浏览器有哪些进程" tabindex="-1">浏览器有哪些进程？ <a class="header-anchor" href="#浏览器有哪些进程" aria-hidden="true">#</a></h2><ul><li>浏览器进程（Browser Process），这个是浏览器的主进程，主要负责包括地址栏、前进后退按钮、文件存取等</li><li>渲染进程（Renderer Process），主要负责将 HTML, CSS, JavaScript 转换为用户可交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 就运行在渲染进程</li><li>网络进程（NetWork Process），主要负责页面的网络资源加载</li><li>插件进程（Plugin Process），主要负责网站使用的所有插件，每个插件一个进程，单独隔离出是为了防止插件挂了影响用户</li><li>GPU（GPU Process），主要负责 UI 渲染</li></ul><h2 id="js在v8中的执行过程" tabindex="-1">js在V8中的执行过程 <a class="header-anchor" href="#js在v8中的执行过程" aria-hidden="true">#</a></h2><h4 id="总流程" tabindex="-1">总流程 <a class="header-anchor" href="#总流程" aria-hidden="true">#</a></h4><img src="http://songnian.gitee.io/imgs/imgs/js%E5%9C%A8v8%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" style="zoom:80%;"><h4 id="js-to-ast" tabindex="-1">JS TO AST <a class="header-anchor" href="#js-to-ast" aria-hidden="true">#</a></h4><blockquote><p><a href="https://esprima.org/demo/parse.html#" target="_blank" rel="noreferrer">AST Parser</a>参考网站，有Token也有AST</p></blockquote><h5 id="词法分析" tabindex="-1">词法分析 <a class="header-anchor" href="#词法分析" aria-hidden="true">#</a></h5><p>所谓词法分析就是将<code>JS</code>代码中的每个字符串，也就是将每个词解析出特定的意义，每个<code>Token</code>主要由一对对的<code>type</code>和<code>value</code>组成。例如<code>var name = &#39;songnian&#39;</code>生成的<code>Token</code>如下：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">[</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// type表示属性/类型  value表示值</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Keyword</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">var</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Identifier</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">name</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Punctuator</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">=</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Identifier</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">songnian</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Punctuator</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">;</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">]</span></span>
<span class="line"></span></code></pre></div><h5 id="语法分析" tabindex="-1">语法分析 <a class="header-anchor" href="#语法分析" aria-hidden="true">#</a></h5><blockquote><p>AST：Abstract Syntax Tree 即抽象语法树</p></blockquote><p>语法分析就是将生成好的<code>Token</code>转化成<code>AST</code>树，如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。最著名的是<code>bable</code>，它可以将<code>ES6</code>原码转化成<code>AST</code>，然后再将这个<code>ES6 AST</code>转成<code>ES5 AST</code>，最后利用<code>ES5 AST</code>转成<code>js</code>执行代码。例如<code>var name = &#39;songnian&#39;</code>生成的<code>AST</code>如下：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">: </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Program</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">body</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">: [</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">VariableDeclaration</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">declarations</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> [</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">VariableDeclarator</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">id</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Identifier</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">name</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">init</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Identifier</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">songnian</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">      ]</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">kind</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">var</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  ]</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">sourceType</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">: </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">script</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h4 id="生成字节码" tabindex="-1">生成字节码 <a class="header-anchor" href="#生成字节码" aria-hidden="true">#</a></h4><blockquote><p>字节码由解释器<code>Ignition</code>生成，它是介于<code>AST</code>和机器码之间的一种代码，它所占用的空间比机器码小很多</p></blockquote><h5 id="缓存机器码" tabindex="-1">缓存机器码 <a class="header-anchor" href="#缓存机器码" aria-hidden="true">#</a></h5><p>在以前的<code>v8</code>引擎中，都是直接将<code>AST</code>转化成机器码然后给<code>CPU</code>执行（因为<code>cpu</code>只认识机器码），但是这样会带来一个问题，就是时间问题，因为每次执行都需要重新编译一次。基于此，<code>Google</code>团队提出了缓存机器码的解决方案，其实就是空间换时间，浏览器运行的时候存放在内存，浏览器关闭后存放在磁盘，但是这样又有一个问题，浏览器运行的时候机器码占用内存很大，非常考验电脑的性能，要是换一个内存小一点的电脑可能就无法支撑了</p><h5 id="惰性编译" tabindex="-1">惰性编译 <a class="header-anchor" href="#惰性编译" aria-hidden="true">#</a></h5><p>为了解决上一个问题，<code>Google</code>团队又提出了惰性编译：<code>V8 </code>启动的时候只编译和缓存全局作用域的代码，而函数作用域中的代码，会在调用的时候去编译，同样函数内部编译后的代码一样不会被缓存下来。一开始还行，但是后来又发现了一个问题，对于以前的<code>jQuery</code>这一些，他们的插件都是通函数去封装的，那么如果一个插件过大就会引起编译的时间很慢，这个惰性编译也就相当于把路给封死了</p><h5 id="引入字节码" tabindex="-1">引入字节码 <a class="header-anchor" href="#引入字节码" aria-hidden="true">#</a></h5><p>从全流程上来看，虽然多了一个生成字节码的环节，但是占用空间却能大大减小</p><h4 id="编译器" tabindex="-1">编译器 <a class="header-anchor" href="#编译器" aria-hidden="true">#</a></h4><h5 id="热代码" tabindex="-1">热代码 <a class="header-anchor" href="#热代码" aria-hidden="true">#</a></h5><p>热代码就是被重复执行多次的代码，在<code>V8</code>中会有专门的监控模块，来监控同一代码是否多次被调用，如果被多次调用，那么就会被标记为<strong>热代码</strong></p><h5 id="优化编译器turbofan" tabindex="-1">优化编译器TurboFan <a class="header-anchor" href="#优化编译器turbofan" aria-hidden="true">#</a></h5><p>接着热代码继续说，当存在热代码的时候，<code>V8</code> 会借着<code>TurboFan </code>将为热代码的字节码转为机器码并缓存下来，这样一来，当再次调用热代码时，就不在需要将字节码转机器码，当然热代码相对来说还是少部分的，所以缓存也并不会占用太大内存，并且提升了执行效率，同样此处也是牺牲空间换时间</p><h5 id="反优化" tabindex="-1">反优化 <a class="header-anchor" href="#反优化" aria-hidden="true">#</a></h5><p>当热代码在某次执行的时候，突然某一个属性被修改了，则此时优化编译器<code>TurboFan</code>会执行<strong>反优化</strong>，其实就是将热代码退回到<code>AST</code>那一步，这个时候解释器<code>Ignition</code>会重新解释执行被修改的代码</p>`,85),p=[l];function c(t,r,d,i,D,F){return o(),a("div",null,p)}const u=s(n,[["render",c]]);export{h as __pageData,u as default};
